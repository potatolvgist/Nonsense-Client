package wtf.bhopper.nonsense.module.impl.exploit;

import meteordevelopment.orbit.EventHandler;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.util.BlockPos;
import net.minecraft.util.Vec3;
import net.minecraft.util.Vec3i;
import org.lwjgl.input.Mouse;
import wtf.bhopper.nonsense.event.impl.EventPreTick;
import wtf.bhopper.nonsense.event.impl.EventRender3D;
import wtf.bhopper.nonsense.gui.hud.notification.Notification;
import wtf.bhopper.nonsense.gui.hud.notification.NotificationType;
import wtf.bhopper.nonsense.module.Module;
import wtf.bhopper.nonsense.module.setting.impl.*;
import wtf.bhopper.nonsense.util.minecraft.client.PacketUtil;
import wtf.bhopper.nonsense.util.minecraft.pathfinding.PathFinding;
import wtf.bhopper.nonsense.util.minecraft.world.BlockUtil;

import java.util.List;

public class Teleport extends Module {

    private final EnumSetting<Mode> mode = new EnumSetting<>("Mode", "mode", Mode.PATH_FIND, value -> {
        this.pathDistance.setDisplayed(value == Mode.PATH_FIND);
        this.maxLoops.setDisplayed(value == Mode.PATH_FIND);
    });

    private final GroupSetting clickGroup = new GroupSetting("Click TP", "Teleport by clicking", this);
    private final BooleanSetting clickTpEnabled = new BooleanSetting("Enabled", "Enables click tp", true);
    private final EnumSetting<ClickTpButton> clickTpButton = new EnumSetting<>("Button", "CLick TP button", ClickTpButton.SHIFT_CLICK);
    private final IntSetting clickTpDistance = new IntSetting("Max Distance", "Max teleport distance", 30, 250, 250);

    private final FloatSetting pathDistance = new FloatSetting("Dash Distance", "Path dash distance", 0.5F, 10.0F, 1.0F);
    private final IntSetting maxLoops = new IntSetting("Max Loops", "max pathfinding loops", 100, 5000, 1000);

    public Teleport() {
        super("Teleport", "portable portal gun to portal you places", Category.EXPLOIT);
        this.clickGroup.add(this.clickTpEnabled, this.clickTpButton, this.clickTpDistance);
        this.addSettings(this.mode, this.clickGroup, this.pathDistance, this.maxLoops);
        this.mode.updateChange();
    }

    private BlockPos teleportPos = null;

    @EventHandler
    public void onTick(EventPreTick event) {

        if (this.teleportPos != null) {

            try {
                this.teleportPlayer(this.teleportPos);
                Notification.send("Teleport", "Teleported to: " + teleportPos.getX() + ", " + teleportPos.getY() + ", " + teleportPos.getZ(), NotificationType.SUCCESS, 3000);
            } catch (IllegalArgumentException exception) {
                Notification.send("Teleport", exception.getMessage(), NotificationType.ERROR, 3000);
            }

            this.teleportPos = null;

        }

    }

    @EventHandler
    public void onRender(EventRender3D event) {

        if (this.clickTpEnabled.get()) {
            if (this.clickButton()) {
                BlockPos pos = mc.thePlayer.rayTrace(clickTpDistance.get(), event.delta).getBlockPos();
                if (pos != null) {
                    while (BlockUtil.isSolid(pos)) {
                        pos = pos.up();
                    }

                    teleportPos = pos;
                }
            }
        }

    }

    public void teleportPlayer(Vec3i vec) {
        this.teleportPlayer(vec.getX() + 0.5, vec.getY(), vec.getZ() + 0.5);
    }

    public void teleportPlayer(Vec3 vec) {
        this.teleportPlayer(vec.xCoord, vec.yCoord, vec.zCoord);
    }

    public void teleportPlayer(double x, double y, double z) {

        if (y > 256.0 || y < 1.0) {
            throw new IllegalArgumentException("Invalid position");
        }

        switch (mode.get()) {

            case INSTANT:
                mc.thePlayer.setPosition(x, y, z);
                break;

            case PATH_FIND:
                List<Vec3> path = PathFinding.getBlinkPath(new BlockPos(x, y, z), 1000);
                for (Vec3 pos : path) {
                    PacketUtil.send(new C03PacketPlayer.C04PacketPlayerPosition(pos.xCoord, pos.yCoord, pos.zCoord, false));
                }
                mc.thePlayer.setPosition(x, y, z);
                break;

        }



    }

    private boolean clickButton() {
        switch (this.clickTpButton.get()) {
            case RIGHT_CLICK:
                return Mouse.isButtonDown(1);

            case SHIFT_CLICK:
                return Mouse.isButtonDown(0) && mc.gameSettings.keyBindSneak.isKeyDown();
        }

        return false;
    }


    private enum Mode {
        INSTANT,
        PATH_FIND
    }

    private enum ClickTpButton {
        RIGHT_CLICK,
        SHIFT_CLICK
    }

}
